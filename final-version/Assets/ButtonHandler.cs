using System;
using System.Collections;
using System.Collections.Generic;

using UnityEngine;
using Solver;

public class ButtonHandler : MonoBehaviour
{

    private RotateSide rs; //reference to the script that rotates the sides of the cube
    private TextHandler th; //referennce to the script to display the moves on the screen

    Cube cube; //algorithmic cube
    CubeSolver solver; //solver for cube

    uint[] scramble; //array to store the scramble that was applied to the cube

    void Start()
    { //called at the start of the program. Initialises objects used for solving/maintaining a cube

        cube = new Cube();
        solver = new CubeSolver();

        rs = FindObjectOfType<RotateSide>();
        th = FindObjectOfType<TextHandler>();
    }
    
    public void Solve()
    { //solves the cube
        
    
        //sequence is used as a placeholder for each generator reduction sequence
        uint[] seq;

        //get the four gen solution, rotate the algorithmic cube and add the moves to queue for the visualiser
        seq = solver.GetFourGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        //above but with three
        seq = solver.GetThreeGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        seq = solver.GetTwoGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        seq = solver.GetOneGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        //two gen returns a single move, as this is all that will ever be needed to solve a final side
        seq = solver.GetZeroGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        //note that this funtion is only used internally to avoid errors with scrambling a cube that isn't solved and losing track
    }

    public void RestartButton()
    { //rotates the cube to be in the starting state of the previous scramble

        print("RESTART");

        //clear the text written, and rewrite scramble
        th.Clear();
        th.Write("NEW", scramble);

        //if there is a scramble to restart, i.e. the cube has already been scrambled once
        if (scramble != null)
        {     
            print("RESTARTING");

            //solve the cube, such that when the scramble is applied again the cube will be in the same state (rather than scrambling it from wherever it is currently)
            Solve();

            //rotate the internal cube by the algorithm, and add the moves to the visualiser queue
            cube = cube.CleanRotatedBySequence(scramble);
            rs.AddMovesToQueue(scramble);
        }

    }

    public void NewButton()
    { //generate and apply a new scramble

        
        print("SCRAMBLE");

        //clear previous example
        th.Clear();

        //solve the cube
        Solve();

        //get a new scramble from the solver
        uint[] seq = solver.GetScramble(18);
        
        //apply the scramble to the internal cube, and add it to the queue of moves in the visualiser
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        //save the scramble such that if the user wants to restart the scramble, they can do so
        this.scramble = seq;

        //write the new scramble
        th.Write("NEW", scramble);
    }

    public void FourGenButton()
    {  //rotates the cube such that it can be generated from solved with the generating set of faces G_4 = {U,L,R,D}

        print("4-GEN");

        //get sequence to reduce from 5-gen to 4-gen (6-gen is equivalent to 5-gen)
        uint[] seq = solver.GetFourGenSolution(cube);

        //apply the moves
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        //add to display
        th.Write("G4", seq);

    }

    public void ThreeGenButton()
    { //rotates the cube such that it can be generated from solved with the generating set of faces G_3 = {U,L,R}
        
        //rotate the cube such that is can be generated by the set G_4.
        FourGenButton();

        print("3-GEN");

        uint[] seq = solver.GetThreeGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        th.Write("G3", seq);
    }

    public void TwoGenButton()
    { //rotates the cube such that it can be generated from solved with the generating set of faces G_3 = {U,R}

        ThreeGenButton();

        print("2-GEN");

        uint[] seq = solver.GetTwoGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        th.Write("G2", seq);
    }

    public void OneGenButton()
    { //rotates the cube such that it can be generated from solved with a generating set of faces, G_1 = {U} or G_1 = {R}

        TwoGenButton();

        print("1-GEN");

        uint[] seq = solver.GetOneGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        th.Write("G1", seq);
    }

    public void ZeroGenButton()
    { //rotates the cube such that it is solved, i.e. generated by the empty set of faces (only one permutation, the identity)

        OneGenButton();

        print("0-GEN");

        uint[] seq = solver.GetZeroGenSolution(cube);
        cube = cube.CleanRotatedBySequence(seq);
        rs.AddMovesToQueue(seq);

        th.Write("G0", seq);
    }

    public void QuitButton()
    {
        
        print("QUITTING");
        Application.Quit();
    }

}